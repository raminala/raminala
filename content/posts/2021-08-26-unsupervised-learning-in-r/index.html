---
title: Unsupervised Learning in R
author: ''
date: '2021-08-26'
slug: []
categories: []
tags:
  - Unsupervised Learning
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>


<pre class="r"><code>x &lt;- read.csv(&quot;x.csv&quot;)
library(tidyverse)</code></pre>
<pre><code>## -- Attaching packages --------------------------------------- tidyverse 1.3.1 --</code></pre>
<pre><code>## v ggplot2 3.3.3     v purrr   0.3.4
## v tibble  3.1.2     v dplyr   1.0.6
## v tidyr   1.1.3     v stringr 1.4.0
## v readr   1.4.0     v forcats 0.5.1</code></pre>
<pre><code>## -- Conflicts ------------------------------------------ tidyverse_conflicts() --
## x dplyr::filter() masks stats::filter()
## x dplyr::lag()    masks stats::lag()</code></pre>
<pre class="r"><code>x %&gt;% ggplot(aes(V1,V2))+geom_point(alpha=0.9, shape=&quot;x&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-1-1.png" width="672" /></p>
<div id="k-means-clustering" class="section level2">
<h2>1-4 k-means clustering</h2>
<p>We have created some two-dimensional data and stored it in a variable called x in your workspace. The scatter plot on the right is a visual representation of the data.</p>
<p>In this exercise, your task is to create a k-means model of the x data using 3 clusters, then to look at the structure of the resulting model using the summary() function.</p>
<pre class="r"><code># Create the k-means model: km.out
km.out &lt;- kmeans(x, centers = 3, nstart = 20)

# Inspect the result
summary(km.out)</code></pre>
<pre><code>##              Length Class  Mode   
## cluster      300    -none- numeric
## centers        9    -none- numeric
## totss          1    -none- numeric
## withinss       3    -none- numeric
## tot.withinss   1    -none- numeric
## betweenss      1    -none- numeric
## size           3    -none- numeric
## iter           1    -none- numeric
## ifault         1    -none- numeric</code></pre>
</div>
<div id="results-of-kmeans" class="section level2">
<h2>1-5 Results of kmeans()</h2>
<p>The kmeans() function produces several outputs. In the video, we discussed one output of modeling, the cluster membership.</p>
<p>In this exercise, you will access the cluster component directly. This is useful anytime you need the cluster membership for each observation of the data used to build the clustering model. A future exercise will show an example of how this cluster membership might be used to help communicate the results of k-means modeling.</p>
<p>k-means models also have a print method to give a human friendly output of basic modeling results. This is available by using print() or simply typing the name of the model.</p>
<pre class="r"><code># Print the cluster membership component of the model

print(km.out$cluster)</code></pre>
<pre><code>##   [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
##  [38] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
##  [75] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1
## [112] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## [149] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## [186] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
## [223] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
## [260] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
## [297] 3 3 3 3</code></pre>
<pre class="r"><code># Print the km.out object
print(km.out)</code></pre>
<pre><code>## K-means clustering with 3 clusters of sizes 100, 100, 100
## 
## Cluster means:
##       X        V1       V2
## 1 150.5 -5.087484 1.882169
## 2  50.5  2.032515 2.032936
## 3 250.5 -2.010368 1.002364
## 
## Clustering vector:
##   [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
##  [38] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
##  [75] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1
## [112] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## [149] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## [186] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
## [223] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
## [260] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
## [297] 3 3 3 3
## 
## Within cluster sum of squares by cluster:
## [1] 83508.93 83508.36 84556.96
##  (between_SS / total_SS =  88.8 %)
## 
## Available components:
## 
## [1] &quot;cluster&quot;      &quot;centers&quot;      &quot;totss&quot;        &quot;withinss&quot;     &quot;tot.withinss&quot;
## [6] &quot;betweenss&quot;    &quot;size&quot;         &quot;iter&quot;         &quot;ifault&quot;</code></pre>
</div>
<div id="visualizing-and-interpreting-results-of-kmeans" class="section level2">
<h2>1-6 Visualizing and interpreting results of kmeans()</h2>
<p>One of the more intuitive ways to interpret the results of k-means models is by plotting the data as a scatter plot and using color to label the samples’ cluster membership. In this exercise, you will use the standard plot() function to accomplish this.</p>
<p>To create a scatter plot, you can pass data with two features (i.e. columns) to plot() with an extra argument col = km.out$cluster, which sets the color of each point in the scatter plot according to its cluster membership.</p>
<pre class="r"><code># Scatter plot of x
x %&gt;%
  ggplot(aes(V1,V2))+geom_point(color=km.out$cluster)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
</div>
<div id="handling-random-algorithms" class="section level2">
<h2>1-8 Handling random algorithms</h2>
<p>In the video, you saw how kmeans() randomly initializes the centers of clusters. This random initialization can result in assigning observations to different cluster labels. Also, the random initialization can result in finding different local minima for the k-means algorithm. This exercise will demonstrate both results.</p>
<p>At the top of each plot, the measure of model quality—total within cluster sum of squares error—will be plotted. Look for the model(s) with the lowest error to find models with the better model results.</p>
<p>Because kmeans() initializes observations to random clusters, it is important to set the random number generator seed for reproducibility.</p>
<pre class="r"><code># Set up 2 x 3 plotting grid
par(mfrow = c(2, 3))

# Set seed
set.seed(1)

for(i in 1:6) {
  # Run kmeans() on x with three clusters and one start
  km.out &lt;- kmeans(x, centers = 3, nstart = 1)
  
  # Plot clusters
  plot(x, col = km.out$cluster, 
       main = km.out$tot.withinss)
}</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-5-1.png" width="672" /><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-5-2.png" width="672" /><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-5-3.png" width="672" /><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-5-4.png" width="672" /><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-5-5.png" width="672" /></p>
</div>
<div id="selecting-number-of-clusters" class="section level2">
<h2>1-9 Selecting number of clusters</h2>
<p>The k-means algorithm assumes the number of clusters as part of the input. If you know the number of clusters in advance (e.g. due to certain business constraints) this makes setting the number of clusters easy. However, as you saw in the video, if you do not know the number of clusters and need to determine it, you will need to run the algorithm multiple times, each time with a different number of clusters. From this, you can observe how a measure of model quality changes with the number of clusters.</p>
<p>In this exercise, you will run kmeans() multiple times to see how model quality changes as the number of clusters changes. Plots displaying this information help to determine the number of clusters and are often referred to as scree plots.</p>
<p>The ideal plot will have an elbow where the quality measure improves more slowly as the number of clusters increases. This indicates that the quality of the model is no longer improving substantially as the model complexity (i.e. number of clusters) increases. In other words, the elbow indicates the number of clusters inherent in the data.</p>
<pre class="r"><code># Initialize total within sum of squares error: wss
wss &lt;- 0

# For 1 to 15 cluster centers
for (i in 1:15) {
  km.out &lt;- kmeans(x, centers = i, nstart = 20)
  # Save total within sum of squares to wss variable
  wss[i] &lt;- km.out$tot.withinss
}

# Plot total within sum of squares vs. number of clusters
plot(1:15, wss, type = &quot;b&quot;, 
     xlab = &quot;Number of Clusters&quot;, 
     ylab = &quot;Within groups sum of squares&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<pre class="r"><code># Set k equal to the number of clusters corresponding to the elbow location
k &lt;- 2  # 3 is probably OK, too</code></pre>
</div>
<div id="practical-matters-working-with-real-data" class="section level2">
<h2>1-11 Practical matters: working with real data</h2>
<p>Dealing with real data is often more challenging than dealing with synthetic data. Synthetic data helps with learning new concepts and techniques, but the next few exercises will deal with data that is closer to the type of real data you might find in your professional or academic pursuits.</p>
<p>The first challenge with the Pokemon data is that there is no pre-determined number of clusters. You will determine the appropriate number of clusters, keeping in mind that in real data the elbow in the scree plot might be less of a sharp elbow than in synthetic data. Use your judgement on making the determination of the number of clusters.</p>
<p>The second part of this exercise includes plotting the outcomes of the clustering on two dimensions, or features, of the data. These features were chosen somewhat arbitrarily for this exercise. Think about how you would use plotting and clustering to communicate interesting groups of Pokemon to other people.</p>
<p>An additional note: this exercise utilizes the iter.max argument to kmeans(). As you’ve seen, kmeans() is an iterative algorithm, repeating over and over until some stopping criterion is reached. The default number of iterations for kmeans() is 10, which is not enough for the algorithm to converge and reach its stopping criterion, so we’ll set the number of iterations to 50 to overcome this issue. To see what happens when kmeans() does not converge, try running the example with a lower number of iterations (e.g. 3). This is another example of what might happen when you encounter real data and use real cases.</p>
<hr />
</div>
<div id="initialize-total-within-sum-of-squares-error-wss" class="section level1">
<h1>Initialize total within sum of squares error: wss</h1>
<p>wss &lt;- 0</p>
</div>
<div id="look-over-1-to-15-possible-clusters" class="section level1">
<h1>Look over 1 to 15 possible clusters</h1>
<p>for (i in 1:15) {
# Fit the model: km.out
km.out &lt;- kmeans(pokemon, centers = i, nstart = 20, iter.max = 50)
# Save the within cluster sum of squares
wss[i] &lt;- km.out$tot.withinss
}</p>
</div>
<div id="produce-a-scree-plot" class="section level1">
<h1>Produce a scree plot</h1>
<p>plot(1:15, wss, type = “b”,
xlab = “Number of Clusters”,
ylab = “Within groups sum of squares”)</p>
</div>
<div id="select-number-of-clusters" class="section level1">
<h1>Select number of clusters</h1>
<p>k &lt;- 3</p>
</div>
<div id="build-model-with-k-clusters-km.out" class="section level1">
<h1>Build model with k clusters: km.out</h1>
<p>km.out &lt;- kmeans(pokemon, centers = k, nstart = 20, iter.max = 50)</p>
</div>
<div id="view-the-resulting-model" class="section level1">
<h1>View the resulting model</h1>
<p>km.out</p>
</div>
<div id="plot-of-defense-vs.-speed-by-cluster-membership" class="section level1">
<h1>Plot of Defense vs. Speed by cluster membership</h1>
<p>plot(pokemon[, c(“Defense”, “Speed”)],
col = km.out$cluster,
main = paste(“k-means clustering of Pokemon with”, k, “clusters”),
xlab = “Defense”, ylab = “Speed”)</p>
<hr />
</div>
